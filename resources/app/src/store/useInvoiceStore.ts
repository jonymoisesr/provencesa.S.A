import { create } from 'zustand';
import { Invoice } from '../types';
import { db } from '../lib/firebase';
import { 
  collection, 
  deleteDoc, 
  doc, 
  onSnapshot, 
  query 
} from 'firebase/firestore';

interface InvoiceState {
  invoices: Invoice[];
  loading: boolean;
  error: string | null;
  subscribe: () => () => void;
  addInvoice: (invoice: Invoice) => Promise<void>;
  deleteInvoice: (id: string) => Promise<void>;
  getInvoice: (id: string) => Invoice | undefined;
}

export const useInvoiceStore = create<InvoiceState>((set, get) => ({
  invoices: [],
  loading: false,
  error: null,

  subscribe: () => {
    set({ loading: true });
    // Assuming invoices have a date or created_at field, defaulting to client timestamp if needed but using explicit date fields is safer if consistent. 
    // For now, sorting by year, month, day might be complex in one go, so maybe created_at is better if I add it. 
    // I'll stick to a simple query for now or add created_at to invoice type if needed. 
    // Existing type has day, month, year. 
    // I will just query all for now, or add created_at to the Invoice type implicitly in firestore.
    const q = query(collection(db, 'invoices')); // Add orderBy if needed later

    const unsubscribe = onSnapshot(q, 
      (snapshot) => {
        const invoices = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Invoice[];
        // Client-side sort if needed
        invoices.sort((a, b) => {
            // Sort by Invoice Number descending
            return parseInt(b.invoice_number) - parseInt(a.invoice_number);
        });
        set({ invoices, loading: false, error: null });
      },
      (error) => {
        console.error("Error fetching invoices:", error);
        set({ error: error.message, loading: false });
      }
    );
    return unsubscribe;
  },

  addInvoice: async (invoice) => {
    try {
      // We don't need to manually generate ID if we let Firestore do it, 
      // BUT the app might expect an ID immediately for navigation.
      // However, addDoc returns a ref with the ID.
      // The current flow passes a full invoice object including an ID (uuid).
      // We can use setDoc with that ID or let Firestore generate one. 
      // To keep it simple and consistent with how I did Supplier, I'll use addDoc and let Firestore key it, 
      // OVERRIDING the uuid generated by the client if necessary, OR I can use setDoc(doc(db, 'invoices', invoice.id), invoice).
      // Using setDoc checks if ID exists.
      
      // Let's use setDoc to preserve the client-generated ID if it's important for the view, 
      // OR better, just use the passed invoice object which potentially has an ID.
      // Actually, standard firestore practice is let the server generate IDs.
      // But the frontend `InvoiceCreatePage` currently generates a UUID.
      // I will keep the client ID as a field, but let Firestore use its own document ID, or use the client ID as the document ID.
      // Using client ID as document ID is cleaner for URLs.
      
      const { setDoc } = await import('firebase/firestore'); // dynamic import or just add to top
      await setDoc(doc(db, 'invoices', invoice.id), invoice);
      
    } catch (error) {
       console.error("Error adding invoice:", error);
       throw error;
    }
  },

  deleteInvoice: async (id) => {
    try {
      await deleteDoc(doc(db, 'invoices', id));
    } catch (error) {
      console.error("Error deleting invoice:", error);
      throw error;
    }
  },

  getInvoice: (id) => get().invoices.find((inv) => inv.id === id),
}));
